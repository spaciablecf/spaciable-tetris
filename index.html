<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
  <title>Spaciable Tetris</title>
  <style>
    :root{
      --primary:#f80954;
      --bg:#0d2b3f;
      --text:#ffffff;
      --border:rgba(255,255,255,.15);
      --cell:rgba(255,255,255,.03);
      --cellBorder:rgba(255,255,255,.10);
      --gap:2px;
      --cellSize:26px;
      /* Background image (40% opacity via ::before) */
      --bgImage:url('https://images.squarespace-cdn.com/content/64edc4eea3459328995c51ca/108cfaa7-05fb-4e0a-8f81-0c0396a7faad/Untitled+design+-+2024-11-06T135610.850.png?content-type=image%2Fpng');
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);font:14px system-ui,Segoe UI,Roboto,Arial;height:100%}
    .wrap{min-height:100svh;min-height:100dvh;min-height:100vh;display:flex;justify-content:center;padding:8px}
    .grid{display:grid;gap:8px;grid-template-columns:1fr auto 280px;max-width:1100px;width:100%}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:#0d2b3f;border:1px solid var(--border);border-radius:16px;padding:12px}
    .title{font-weight:800;font-size:20px;margin:0 0 8px}
    .label{font-size:12px;color:rgba(255,255,255,.7)}
    .val{font-size:18px;font-weight:800}
    .btn{padding:8px 12px;border-radius:12px;border:0;cursor:pointer;font-weight:700}
    .btn-start{background:var(--primary);color:#fff}
    .btn-pause{background:#fff;color:#0d2b3f}
    .btn-reset{background:rgba(255,255,255,.12);color:#fff}
    .cells{position:relative;z-index:1;display:grid;gap:var(--gap)}
    .cell{
      width:var(--cellSize);
      height:var(--cellSize);
      background:var(--cell);
      border:1px solid var(--cellBorder);
      border-radius:4px;
      box-shadow:inset 0 0 6px rgba(0,0,0,.25)
    }
    .boardWrap{display:flex;justify-content:center}
    .board{
      position:relative;
      background:#0b1f2c;
      border:1px solid var(--border);
      border-radius:12px;
      padding:6px;
      overflow:hidden;
      touch-action:manipulation;
    }
    /* Background image layer behind the grid */
    .board::before{
      content:"";
      position:absolute;
      inset:6px;
      background-image:var(--bgImage);
      background-size:cover;
      background-position:center;
      opacity:.40;
      border-radius:8px;
      z-index:0;
      pointer-events:none;
      filter:saturate(1) contrast(1.05);
    }
    .rightCol{display:flex;flex-direction:column;gap:12px}

    /* Touch control pad (floats above content, but we keep it narrow) */
    #touchControls {
      display:none;
      position:fixed;
      left:50%;
      bottom: clamp(8px, 2vh, 16px);
      transform:translateX(-50%);
      gap:8px;
      background:rgba(13,43,63,0.85);
      padding:8px 12px;
      border-radius:12px;
      z-index:1000;
      -webkit-user-select:none; user-select:none;
      box-shadow:0 6px 20px rgba(0,0,0,.25);
    }
    #touchControls button {
      font-size:20px;
      padding:12px 14px;
      border:none;
      border-radius:10px;
      background:var(--primary);
      color:#fff;
      cursor:pointer;
    }
    @media(max-width:768px){
      #touchControls{display:flex;}
      /* Stack side panels under the board on mobile for more vertical space */
      .grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="grid">
    <div class="card controls">
      <h2 class="title">Spaciable Tetris</h2>
      <div style="margin-bottom:8px" class="label">Time limit, custom speed & leaderboard</div>
      <div>
        <label class="label">Minutes</label>
        <input id="minInput" type="number" min="0" max="59" value="2"/>
        <label class="label">Seconds</label>
        <input id="secInput" type="number" min="0" max="59" value="0"/>
        <label class="label">Start Speed</label>
        <input id="spdInput" type="number" min="1" max="20" value="1"/>
        <div><input id="fixedChk" type="checkbox"/> <span class="label">Keep speed fixed</span></div>
      </div>
      <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap">
        <button id="startBtn" class="btn btn-start">Start</button>
        <button id="pauseBtn" class="btn btn-pause">Pause</button>
        <button id="resetBtn" class="btn btn-reset">Reset</button>
      </div>
      <div style="margin-top:10px" class="label">Score: <span id="scoreVal" class="val">0</span></div>
      <div class="label">Lines: <span id="linesVal" class="val">0</span></div>
      <div class="label">Level: <span id="levelVal" class="val">1</span></div>
      <div class="label">Time: <span id="timeVal" class="val">02:00</span></div>
    </div>

    <div class="boardWrap">
      <div class="board"><div id="board" class="cells"></div></div>
    </div>

    <div class="rightCol">
      <div class="card"><div class="label">Next</div><div id="nextWrap"></div></div>
      <div class="card"><div class="label">Leaderboard</div><ol id="lb"></ol></div>
    </div>
  </div>
</div>

<!-- Touch controls -->
<div id="touchControls" aria-label="Touch controls">
  <button data-action="left"   aria-label="Move left">←</button>
  <button data-action="rotate" aria-label="Rotate">⟳</button>
  <button data-action="right"  aria-label="Move right">→</button>
  <button data-action="down"   aria-label="Soft drop">↓</button>
  <button data-action="hard"   aria-label="Hard drop">⏬</button>
</div>

<script>
(function(){
  const COLS=10, ROWS=20;
  const STORAGE_LB='custom-tetris-leaderboard';
  const SHAPES={
    I:[[0,0,0,0],[1,1,1,1]],
    J:[[1,0,0],[1,1,1]],
    L:[[0,0,1],[1,1,1]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0]],
    T:[[0,1,0],[1,1,1]],
    Z:[[1,1,0],[0,1,1]]
  };
  const COLORS={I:'#22d3ee',J:'#3b82f6',L:'#f59e0b',O:'#fde047',S:'#34d399',T:'#a855f7',Z:'#f43f5e'};

  const $=id=>document.getElementById(id);
  const boardEl=$('board'), nextWrap=$('nextWrap'), lbEl=$('lb');
  const scoreVal=$('scoreVal'), linesVal=$('linesVal'), levelVal=$('levelVal'), timeVal=$('timeVal');
  const minInput=$('minInput'), secInput=$('secInput'), spdInput=$('spdInput'), fixedChk=$('fixedChk');
  const startBtn=$('startBtn'), pauseBtn=$('pauseBtn'), resetBtn=$('resetBtn');

  let board,queue,current,score,lines,level,dropInterval,gravTimer,tickTimer,running,paused,totalSeconds,remaining,startSpeed,fixedSpeed;

  function empty(){return Array.from({length:ROWS},()=>Array(COLS).fill(null))}
  const clone=b=>b.map(r=>r.slice());
  function randomBag(){return ['I','J','L','O','S','T','Z'].sort(()=>Math.random()-.5)}
  function piece(t){const s=SHAPES[t].map(r=>r.slice());return{type:t,shape:s,x:3,y:-2}}

  function collide(b,p,dx=0,dy=0){
    for(let r=0;r<p.shape.length;r++){
      for(let c=0;c<p.shape[r].length;c++){
        if(p.shape[r][c]){
          const nx=p.x+c+dx,ny=p.y+r+dy;
          if(nx<0||nx>=COLS||ny>=ROWS)return true;
          if(ny>=0&&b[ny][nx])return true;
        }
      }
    }return false;
  }
  function merge(b,p){const nb=clone(b);p.shape.forEach((row,r)=>row.forEach((v,c)=>{if(v&&p.y+r>=0)nb[p.y+r][p.x+c]=p.type}));return nb}
  function clearLines(b){const nb=[];let cl=0;for(let r=0;r<ROWS;r++){if(b[r].every(v=>v))cl++;else nb.push(b[r])}while(nb.length<ROWS)nb.unshift(Array(COLS).fill(null));return{board:nb,cleared:cl}}
  function rot(s){return s[0].map((_,c)=>s.map(row=>row[c]).reverse())}

  function buildBoard(){
    boardEl.style.display='grid';
    boardEl.style.gap='var(--gap)';
    boardEl.style.gridTemplateColumns=`repeat(${COLS}, var(--cellSize))`;
    boardEl.innerHTML='';
    for(let i=0;i<COLS*ROWS;i++){const d=document.createElement('div');d.className='cell';boardEl.appendChild(d)}
  }

  // Make the board as big as possible in the current viewport, accounting for UI
  function fitBoardToViewport(){
    const container=document.querySelector('.board');
    if(!container)return;

    // Available width (inner content area)
    const w = container.clientWidth - 12;

    // Available height: from top of the board to the bottom of the viewport,
    // minus touch controls (if visible) and a little breathing room.
    const rect = container.getBoundingClientRect();
    let h = window.innerHeight - rect.top;

    const tc = document.getElementById('touchControls');
    if (tc && getComputedStyle(tc).display!=='none') {
      h -= (tc.offsetHeight + 24);
    } else {
      h -= 24;
    }

    const gap=2;
    const sizeW=Math.floor((w-(COLS-1)*gap)/COLS);
    const sizeH=Math.floor((h-(ROWS-1)*gap)/ROWS);

    // Clamp to sensible limits
    const size=Math.max(14,Math.min(32,Math.min(sizeW,sizeH)));
    document.documentElement.style.setProperty('--cellSize', size+'px');
  }

  function draw(){
    const cells=boardEl.children,temp=clone(board);
    if(current){
      for(let r=0;r<current.shape.length;r++)
        for(let c=0;c<current.shape[r].length;c++)
          if(current.shape[r][c]){
            const ny=current.y+r,nx=current.x+c;
            if(ny>=0)temp[ny][nx]=current.type;
          }
    }
    let k=0;
    for(let r=0;r<ROWS;r++)
      for(let c=0;c<COLS;c++){
        const cell=cells[k++],v=temp[r][c];
        cell.style.background=v?COLORS[v]:'var(--cell)';
        cell.style.borderColor=v?'rgba(0,0,0,.25)':'var(--cellBorder)';
      }
    scoreVal.textContent=score;linesVal.textContent=lines;levelVal.textContent=level;
    timeVal.textContent=String(Math.floor(remaining/60)).padStart(2,'0')+':'+String(remaining%60).padStart(2,'0');
  }

  function drawNext(){
    nextWrap.innerHTML='';
    queue.slice(0,3).forEach(t=>{
      const shape=SHAPES[t],scale=12,mini=document.createElement('div');
      mini.style.display='grid';mini.style.gap='2px';
      mini.style.gridTemplateColumns=`repeat(${shape[0].length}, ${scale}px)`;
      shape.flat().forEach(v=>{
        const d=document.createElement('div');
        d.style.width=scale+'px';d.style.height=scale+'px';
        d.style.background=v?COLORS[t]:'rgba(255,255,255,.12)';
        d.style.borderRadius='2px';
        mini.appendChild(d);
      });
      nextWrap.appendChild(mini);
    });
  }

  function refill(){if(queue.length<7)queue=queue.concat(randomBag())}
  function spawn(){refill();current=piece(queue.shift());drawNext();if(collide(board,current))endGame()}

  function levelInterval(l){return Math.max(120,800-(l-1)*60)}
  function startGame(){
    if(running)return;
    const m=parseInt(minInput.value||0,10),s=parseInt(secInput.value||0,10);
    startSpeed=parseInt(spdInput.value||1,10);fixedSpeed=!!fixedChk.checked;
    totalSeconds=m*60+s;remaining=totalSeconds||120;
    board=empty();queue=randomBag();current=null;
    score=0;lines=0;level=startSpeed;dropInterval=levelInterval(level);
    paused=false;running=true;spawn();draw();
    if(gravTimer)clearInterval(gravTimer);
    gravTimer=setInterval(()=>{if(!paused&&running)softDrop();},dropInterval);
    if(tickTimer)clearInterval(tickTimer);
    tickTimer=setInterval(()=>{if(!running||paused)return;remaining--;if(remaining<=0){remaining=0;endGame();}draw();},1000);
  }
  function endGame(){running=false;paused=false;clearInterval(gravTimer);clearInterval(tickTimer);}
  function pauseResume(){if(running)paused=!paused;}
  function resetGame(){running=false;clearInterval(gravTimer);clearInterval(tickTimer);board=empty();queue=[];current=null;score=0;lines=0;level=1;remaining=totalSeconds;draw();drawNext();}
  function tryMove(dx,dy){if(current&&!collide(board,current,dx,dy)){current.x+=dx;current.y+=dy;draw();}}
  function rotatePiece(){if(current){const t={...current,shape:rot(current.shape)};if(!collide(board,t))current=t;draw();}}
  function lock(){board=merge(board,current);const {board:nb,cleared}=clearLines(board);board=nb;if(cleared){score+=(cleared*100)*level;lines+=cleared;if(!fixedSpeed){const nl=Math.floor(lines/10)+startSpeed;if(nl!==level){level=nl;clearInterval(gravTimer);gravTimer=setInterval(()=>{if(!paused&&running)softDrop();},levelInterval(level));}}}spawn();draw();}
  function softDrop(){if(current&&!collide(board,current,0,1))current.y++;else lock();draw();}
  function hardDrop(){while(current&&!collide(board,current,0,1))current.y++;lock();}

  function loadLB(){try{return JSON.parse(localStorage.getItem(STORAGE_LB)||'[]');}catch{return[]}}
  function saveLB(x){localStorage.setItem(STORAGE_LB,JSON.stringify(x))}
  function renderLB(){const items=loadLB().slice(0,10);lbEl.innerHTML='';if(items.length===0){lbEl.innerHTML='<li>No scores yet</li>';return;}items.forEach((it,i)=>{const li=document.createElement('li');li.textContent=(i+1)+'. '+(it.name||'Player')+' — '+it.score;lbEl.appendChild(li);});}

  // Bind buttons (ensure they exist before binding)
  startBtn?.addEventListener('click',startGame);
  pauseBtn?.addEventListener('click',pauseResume);
  resetBtn?.addEventListener('click',resetGame);

  // Keyboard
  window.addEventListener('keydown',e=>{
    if(e.code==='Space') e.preventDefault();
    if(e.code==='KeyP'){ e.preventDefault(); return pauseResume(); }
    if(e.code==='KeyR'){ e.preventDefault(); return resetGame(); }
    if(!running||paused||!current) return;
    switch(e.code){
      case'ArrowLeft':e.preventDefault();tryMove(-1,0);break;
      case'ArrowRight':e.preventDefault();tryMove(1,0);break;
      case'ArrowDown':e.preventDefault();softDrop();break;
      case'ArrowUp':e.preventDefault();rotatePiece();break;
      case'Space':e.preventDefault();hardDrop();break;
    }
  },{passive:false});

  // Touch controls (don’t steal clicks from top UI)
  document.querySelectorAll('#touchControls button').forEach(btn=>{
    btn.addEventListener('touchstart',e=>{
      e.preventDefault();
      if(!running||paused)return;
      switch(btn.dataset.action){
        case'left':tryMove(-1,0);break;
        case'right':tryMove(1,0);break;
        case'down':softDrop();break;
        case'rotate':rotatePiece();break;
        case'hard':hardDrop();break;
      }
    },{passive:false});
  });

  function boot(){
    board=empty();queue=[];current=null;score=0;lines=0;level=1;totalSeconds=120;remaining=120;startSpeed=1;fixedSpeed=false;
    buildBoard(); fitBoardToViewport(); draw(); drawNext(); renderLB();
  }
  boot();
  window.addEventListener('resize',fitBoardToViewport);
  window.addEventListener('orientationchange',fitBoardToViewport);
  // Re-fit after fonts/UI paint
  setTimeout(fitBoardToViewport, 50);
})();
</script>
</body>
</html>
